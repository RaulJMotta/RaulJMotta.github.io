<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="utf-t" />
    <title>Mapa de Análise de Vias</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f0f0;
        }

        #controls {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: white;
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-size: 11px;
            font-weight: bold;
            color: #666;
            margin-bottom: 4px;
        }
        
        .control-group select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        #map {
            width: 100%;
            height: 100vh;
        }
        
        /* Estilos da Legenda */
        .legend {
            background: white;
            padding: 10px 15px; /* Adiciona um pouco de padding lateral */
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,.2);
            font-size: 12px;
            color: #555;
            width: 250px;
        }
        .legend-title {
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }
        .legend-bar {
            display: flex;
            height: 15px;
            border-radius: 3px;
            overflow: hidden;
        }
        .legend-bar span {
            flex: 1;
            display: flex;             /* Ativa o flexbox para o alinhamento */
            align-items: center;       /* Centraliza verticalmente */
            justify-content: center;   /* Centraliza horizontalmente */
            color: white;              /* Cor do texto */
            font-weight: bold;         /* Deixa o texto em negrito */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5); /* Sombra para legibilidade */
        }
        .legend-q1 { background: #d73027; }
        .legend-q2 { background: #fdae61; }
        .legend-q3 { background: #91cf60; }
        .legend-q4 { background: #1a9850; }

        /* --- NOVO MÉTODO DE POSICIONAMENTO --- */
        .legend-labels {
            position: relative; /* Cria o contexto para o posicionamento absoluto */
            height: 35px; /* Espaço para os textos, incluindo "ruim/bom" */
            margin-top: 5px;
        }
        .legend-labels span {
            position: absolute; /* Posiciona cada texto de forma independente */
            top: 0;
            width: 60px; /* Largura para evitar que textos longos se sobreponham */
            text-align: center;
            white-space: nowrap;
        }

        /* Define a posição exata de cada texto */
        .legend-labels .label-start {
            left: 0;
            text-align: left;
        }
        .legend-labels .label-q1 {
            left: 25%;
            transform: translateX(-50%); /* Centraliza o texto na marca de 25% */
        }
        .legend-labels .label-q2 {
            left: 50%;
            transform: translateX(-50%); /* Centraliza o texto na marca de 50% */
        }
        .legend-labels .label-q3 {
            left: 75%;
            transform: translateX(-50%); /* Centraliza o texto na marca de 75% */
        }
        .legend-labels .label-end {
            right: 0; /* Alinha a borda DIREITA do texto à borda DIREITA do container */
            text-align: right;
        }

        .legend-labels small {
            display: block;
            font-size: 10px;
            color: #777;
            margin-top: 2px;
        }
    </style>
</head>
<body>

    <div id="controls">
        <div class="control-group">
            <label for="city-select">City</label>
            <select id="city-select">
                <option value="POA">Porto Alegre</option>
                <option value="Concepcion">Concepción</option>
            </select>
        </div>
        <div class="control-group">
            <label for="attribute-select">Attribute</label>
            <select id="attribute-select">
                </select>
        </div>
    </div>

    <div id="map"></div>

    <script>
        // --- VARIÁVEIS GLOBAIS ---
        let map;
        let geojsonLayer = null;
        let legendControl = null;
        let allData = null; // Armazena todos os dados do GeoJSON
        let cityData = {}; // Armazena dados separados por cidade
        let quartileBreaks = {}; // Armazena os quartis calculados para a legenda

        const citySelector = document.getElementById('city-select');
        const attributeSelector = document.getElementById('attribute-select');

        const attributeMap = {
        'F0_WI': 'Walkability Index',
        'F1_DELSIDE': 'Delimited Sidewalks',
        'F2_SIDEWID': 'Sidewalk Width',
        'F3_QUALITY': 'Quality of Pavement'
        };

        // --- FUNÇÕES DE LÓGICA DO MAPA ---

        /**
         * Inicializa o mapa Leaflet e o tile layer.
         */
        function initMap() {
            map = L.map('map').setView([-22.9, -43.2], 4); // Visão inicial geral
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
        }

        /**
        * Retorna a cor baseada no valor e nos quartis calculados (escala "ruim-bom").
        */
        
        function getColor(value, breaks) {
            // Se o valor for nulo ou indefinido, retorna preto. Esta é a nova regra.
            if (value === undefined || value === null) {
                return '#000000'; // Preto para dados faltantes
            }

            // Se não houver breaks definidos, retorna uma cor de erro (cinza).
            if (!breaks || breaks.q3 === undefined) {
                return '#808080';
            }
            
            // A lógica de cores permanece a mesma, funcionando para qualquer conjunto de breaks.
            return value <= breaks.q1 ? '#d73027' :  // Q1 (Ruim)
                value <= breaks.q2 ? '#fdae61' :  // Q2
                value <= breaks.q3 ? '#91cf60' :  // Q3
                                        '#1a9850';   // Q4 (Bom)
        }

        /**
         * Estiliza as feições baseando-se no atributo selecionado.
         */
        
        function styleFeature(feature) {
            const selectedAttribute = attributeSelector.value;
            const props = feature.properties;
            
            if (selectedAttribute === 'F0_WI') {
                const value = props.F0_WI;
                return {
                    color: getColor(value, quartileBreaks), // Usa os quartis dinâmicos
                    weight: 4,
                    opacity: 0.9
                };
            } else {
                const value = props[selectedAttribute];
                // Define os breaks fixos para os outros atributos
                const fixedBreaks = { q1: 0.25, q2: 0.50, q3: 0.75 };
                return {
                    color: getColor(value, fixedBreaks), // Usa os breaks fixos
                    weight: 3,
                    opacity: 0.8
                };
            }
        }

        /**
         * Define o conteúdo do popup para cada feição.
         */

        function onEachFeature(feature, layer) {
            layer.on('click', function (e) {
                const selectedAttributeKey = attributeSelector.value;
                const props = feature.properties;
                
                // --- 1. Pega os valores do atributo e do endereço ---
                const value = props[selectedAttributeKey];
                const address = props.NMIDELOG; // Pega o endereço do campo NMIDELOG

                const displayName = attributeMap[selectedAttributeKey] || selectedAttributeKey;
                
                let formattedValue;

                // Lógica para formatar o valor do atributo (números, nulos, etc.)
                if (typeof value === 'number' && !isNaN(value)) {
                    if (selectedAttributeKey === 'F0_WI') {
                        formattedValue = value.toFixed(3);
                    } else {
                        formattedValue = value.toFixed(2);
                    }
                } else {
                    if (value === null || value === undefined) {
                        formattedValue = 'No Data';
                    } else {
                        formattedValue = value;
                    }
                }
                
                // --- 2. Monta o novo conteúdo do popup ---
                // Adiciona a linha "Street Name:" no topo.
                let content = `
                    <b>Street Name:</b><br>
                    ${address ? address : 'No Data'}<br><br>
                    <b>${displayName}:</b><br>
                    ${formattedValue}
                `;
                
                L.popup()
                    .setLatLng(e.latlng)
                    .setContent(content)
                    .openOn(map);
            });
        }
        
        /**
         * Calcula os quartis (Q1, Q2, Q3) para a legenda a partir dos dados visíveis.
         */
        function calculateQuartiles(data, field) {
            const values = data.features
                .map(f => f.properties[field])
                .filter(v => v !== null && !isNaN(v)) // Filtra nulos e não-números
                .sort((a, b) => a - b);

            if (values.length < 4) { // Não é possível calcular quartis com poucos dados
                return { q1: null, q2: null, q3: null };
            }

            const q1Index = Math.floor(values.length / 4);
            const q2Index = Math.floor(values.length / 2);
            const q3Index = Math.floor(values.length * 3 / 4);

            return {
                q1: values[q1Index],
                q2: values[q2Index],
                q3: values[q3Index]
            };
        }

        /**
        * Atualiza ou cria a legenda no mapa com estilo de barra horizontal.
        */

        function updateLegend() {
            // Remove a legenda antiga, se existir
            if (legendControl) {
                map.removeControl(legendControl);
                legendControl = null;
            }

            const selectedAttributeKey = attributeSelector.value;
            const selectedAttributeName = attributeMap[selectedAttributeKey] || selectedAttributeKey;
            
            let breaks;
            let title = selectedAttributeName; // O título da legenda será o nome amigável

            // Decide se usa os breaks dinâmicos ou fixos
            if (selectedAttributeKey === 'F0_WI') {
                // Se for o Walkability Index, usa os quartis calculados
                if (!quartileBreaks.q1) return; // Não mostra legenda se não houver dados
                breaks = quartileBreaks;
            } else {
                // Para todos os outros atributos, usa os breaks fixos
                breaks = { q1: 0.25, q2: 0.50, q3: 0.75 };
            }

            legendControl = L.control({ position: 'bottomright' });
            legendControl.onAdd = function () {
                var div = L.DomUtil.create('div', 'legend');
                
                // Formata os números dos breaks com o número de casas decimais apropriado
                const q1Text = breaks.q1.toFixed(selectedAttributeKey === 'F0_WI' ? 3 : 2);
                const q2Text = breaks.q2.toFixed(selectedAttributeKey === 'F0_WI' ? 3 : 2);
                const q3Text = breaks.q3.toFixed(selectedAttributeKey === 'F0_WI' ? 3 : 2);

                div.innerHTML = `
                    <div class="legend-title">${title}</div>
                    <div class="legend-bar">
                        <span class="legend-q1">Q1</span>
                        <span class="legend-q2">Q2</span>
                        <span class="legend-q3">Q3</span>
                        <span class="legend-q4">Q4</span>
                    </div>
                    <div class="legend-labels">
                        <span class="label-start">0<small>Bad</small></span>
                        <span class="label-q1">${q1Text}</span>
                        <span class="label-q2">${q2Text}</span>
                        <span class="label-q3">${q3Text}</span>
                        <span class="label-end">1<small>Good</small></span>
                    </div>
                `;
                return div;
            };
            legendControl.addTo(map);
        }

        /**
         * Função principal que filtra, exibe a cidade e atualiza o mapa.
         */
        function displayCity() {
            const selectedCity = citySelector.value;
            const cityGeoJSON = cityData[selectedCity];

            if (!cityGeoJSON) return;

            // Remove a camada antiga do mapa
            if (geojsonLayer) {
                map.removeLayer(geojsonLayer);
            }

            // Calcula os quartis para a cidade selecionada ANTES de criar a camada
            quartileBreaks = calculateQuartiles(cityGeoJSON, 'F0_WI');
            
            // --- ADICIONE ESTA LINHA PARA DEPURAR ---
            console.log("Quartis calculados para a cidade:", selectedCity, quartileBreaks);
            // -----------------------------------------


            // Cria a nova camada GeoJSON com estilo e popups
            geojsonLayer = L.geoJSON(cityGeoJSON, {
                style: styleFeature,
                onEachFeature: onEachFeature
            }).addTo(map);

            // Dá zoom nas feições da cidade
            if (cityGeoJSON.features.length > 0) {
                map.fitBounds(geojsonLayer.getBounds().pad(0.1));
            }
            
            // Atualiza a legenda
            updateLegend();
        }


        // --- INICIALIZAÇÃO E CARREGAMENTO DE DADOS ---

        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            
            fetch("meu_mapa.geojson")
                .then(response => response.json())
                .then(data => {
                    allData = data;
                    
                    // Separa os dados por cidade (mantendo a sua correção de espaços)
                    cityData.POA = { type: "FeatureCollection", features: data.features.filter(f => f.properties.layer.trim().replace(/\s+/g, ' ') === 'Vias final POA') };
                    cityData.Concepcion = { type: "FeatureCollection", features: data.features.filter(f => f.properties.layer.trim() === 'eje_central_Concepcion') };
                    
                    // --- LÓGICA DO SELETOR ATUALIZADA ---
                    const attributesToShow = ['F0_WI', 'F1_DELSIDE', 'F2_SIDEWID', 'F3_QUALITY'];
                    
                    attributesToShow.forEach(propKey => {
                        const option = document.createElement('option');
                        option.value = propKey; // O valor interno continua sendo a chave (ex: "F0_WI")
                        // O texto visível vem do nosso mapa de tradução
                        option.textContent = attributeMap[propKey] || propKey; 
                        attributeSelector.appendChild(option);
                    });
                    // ------------------------------------

                    // Adiciona os Event Listeners depois que os dados foram carregados
                    citySelector.addEventListener('change', displayCity);
                    
                    attributeSelector.addEventListener('change', () => {
                        if (geojsonLayer) {
                            geojsonLayer.setStyle(styleFeature); // Re-aplica o estilo
                            updateLegend(); // Atualiza a legenda
                        }
                    });

                    // Exibe a cidade padrão ao carregar
                    displayCity();
                })
                .catch(error => console.error("Erro ao carregar o GeoJSON:", error));
        });

    </script>
</body>
</html>
